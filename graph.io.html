<!DOCTYPE html>
<html>

<head>
  <title>graph.io</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <canvas id="c"></canvas>
  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    canvas.width = innerWidth;
    canvas.height = innerHeight;

    window.addEventListener('resize', () => {
      canvas.width = innerWidth;
      canvas.height = innerHeight;
    });

    const CAM_SMOOTH = 0.03, ZOOM_SMOOTH = 0.01;
    const GRID_SIZE = 100, GRID_COLOR = '#222';
    const UNCLAIMED_COLOR = "#888";
    const MAX_SCREEN_FILL = 0.6, MIN_ZOOM = 0.5, MAX_ZOOM = 1;
    const HOLD_CLICK_INTERVAL = 1000 / 60;
    const DOT_RADIUS = 6;
    const CLICK_ANIM_DURATION = 727;
    const TRAIL_ANIM_DURATION = 1000;

    let myId = null, MAP_W = 3000, MAP_H = 2000, CLICK_RANGE = 200;
    let dots = [], connections = [], stamina = 100;
    let camX = 0, camY = 0, zoom = 1, camInitialized = false;

    function getHue(id) {
      return id === myId ? 120 : ((id * 173) % 280) + 160;
    }

    function getColor(id, alpha = 1) {
      const hue = getHue(id);
      return id === myId ? `rgba(0, 187, 0, ${alpha})` : `hsla(${hue}, 70%, 50%, ${alpha})`;
    }

    const ws = new WebSocket('ws://localhost:8080');

    ws.onmessage = e => {
      const msg = JSON.parse(e.data);
      if (msg.type === 'init') { myId = msg.id; MAP_W = msg.MAP_W; MAP_H = msg.MAP_H; CLICK_RANGE = msg.CLICK_RANGE; }
      else if (msg.type === 'state') { dots = msg.dots; connections = msg.connections; stamina = msg.stamina; }
      else if (msg.type === 'click') handleRemoteClick(msg);
    };

    let mouseDown = false, mouseX = 0, mouseY = 0, lastClickX = null, lastClickY = null;
    const clickEffects = [];
    const dragTrails = []; // [{points: [{x,y}], birth, width, alpha}]
    const remoteTrails = {}; // playerId -> trail

    function isInRange(x, y) {
      return dots.some(d => d.owner === myId && Math.hypot(d.x - x, d.y - y) < CLICK_RANGE);
    }

    function clampToRange(x, y) {
      if (isInRange(x, y)) return { x, y };
      let best = null, bestDist = Infinity;
      for (const d of dots) {
        if (d.owner !== myId) continue;
        const dist = Math.hypot(d.x - x, d.y - y);
        const edgeDist = dist - CLICK_RANGE;
        if (edgeDist < bestDist) {
          bestDist = edgeDist;
          const t = (CLICK_RANGE - 1) / dist;
          best = { x: d.x + (x - d.x) * t, y: d.y + (y - d.y) * t };
        }
      }
      return best;
    }

    function addClickEffect(x, y, stam, playerId = myId) {
      const t = stam / 100;
      clickEffects.push({ x, y, radius: 0, maxRadius: 20 + 80 * t, alpha: 0.1 + 0.4 * t, hue: getHue(playerId), birth: Date.now() });
    }

    function handleRemoteClick(msg) {
      const { id, x, y, px, py, stam } = msg;
      if (px !== undefined) {
        if (!remoteTrails[id]) {
          remoteTrails[id] = { points: [{ x: px, y: py, t: Date.now(), stam }], birth: Date.now(), playerId: id };
          dragTrails.push(remoteTrails[id]);
        }
        remoteTrails[id].points.push({ x, y, t: Date.now(), stam });
      } else {
        remoteTrails[id] = null;
        addClickEffect(x, y, stam, id);
      }
    }

    let currentTrail = null, lastTrailX = null, lastTrailY = null, wasInRange = false;
    const TRAIL_MIN_DIST = 5;
    function addToTrail(x, y, stam) {
      const inRange = isInRange(x, y);
      if (!inRange) {
        currentTrail = null;
        lastTrailX = null;
        lastTrailY = null;
        wasInRange = false;
        return;
      }
      if (!wasInRange) {
        lastTrailX = x; lastTrailY = y;
        wasInRange = true;
        return;
      }

      if (!currentTrail) {
        if (Math.hypot(x - lastTrailX, y - lastTrailY) < TRAIL_MIN_DIST) {
          lastTrailX = x; lastTrailY = y;
          return;
        }
        currentTrail = { points: [{ x: lastTrailX, y: lastTrailY, t: Date.now(), stam }], birth: Date.now() };
        dragTrails.push(currentTrail);
      }
      currentTrail.points.push({ x, y, t: Date.now(), stam });
      if (currentTrail.points.length > 1) { lastTrailX = x; lastTrailY = y; }
    }

    // WebGL setup for trails (uses gl.MAX blend to avoid overlap artifacts)
    const glCanvas = document.createElement('canvas');
    glCanvas.style.cssText = 'position:absolute;top:0;left:0;pointer-events:none';
    document.body.appendChild(glCanvas);
    const gl = glCanvas.getContext('webgl2');

    const vs = `
      attribute vec2 pos;
      uniform vec2 res, cam;
      uniform float zoom;
      void main() {
        vec2 p = (pos - cam) * zoom + res * 0.5;
        gl_Position = vec4(p / res * 2.0 - 1.0, 0, 1);
        gl_Position.y *= -1.0;
      }
    `;
    const fs = `
      precision mediump float;
      uniform vec4 color;
      void main() { gl_FragColor = color; }
    `;

    function compileShader(src, type) {
      const s = gl.createShader(type);
      gl.shaderSource(s, src);
      gl.compileShader(s);
      return s;
    }

    const prog = gl.createProgram();
    gl.attachShader(prog, compileShader(vs, gl.VERTEX_SHADER));
    gl.attachShader(prog, compileShader(fs, gl.FRAGMENT_SHADER));
    gl.linkProgram(prog);
    gl.useProgram(prog);

    const posLoc = gl.getAttribLocation(prog, 'pos');
    const resLoc = gl.getUniformLocation(prog, 'res');
    const camLoc = gl.getUniformLocation(prog, 'cam');
    const zoomLoc = gl.getUniformLocation(prog, 'zoom');
    const colorLoc = gl.getUniformLocation(prog, 'color');

    const buf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

    gl.enable(gl.BLEND);
    gl.blendEquation(gl.MAX);
    gl.blendFunc(gl.ONE, gl.ONE);

    function resizeGL() {
      glCanvas.width = innerWidth;
      glCanvas.height = innerHeight;
      gl.viewport(0, 0, glCanvas.width, glCanvas.height);
    }
    resizeGL();
    addEventListener('resize', resizeGL);

    function dist(a, b) {
      return Math.hypot(b.x - a.x, b.y - a.y);
    }

    function lerp(a, b, t) {
      return {
        x: a.x + (b.x - a.x) * t,
        y: a.y + (b.y - a.y) * t
      };
    }

    function catmullRomCentripetal(p0, p1, p2, p3, t) {
      const alpha = 0.5;

      const t0 = 0;
      const t1 = t0 + Math.pow(dist(p0, p1), alpha);
      const t2 = t1 + Math.pow(dist(p1, p2), alpha);
      const t3 = t2 + Math.pow(dist(p2, p3), alpha);

      // remap t from [0,1] â†’ [t1,t2]
      const tt = t1 + (t2 - t1) * t;

      const A1 = lerp(p0, p1, (tt - t0) / (t1 - t0));
      const A2 = lerp(p1, p2, (tt - t1) / (t2 - t1));
      const A3 = lerp(p2, p3, (tt - t2) / (t3 - t2));

      const B1 = lerp(A1, A2, (tt - t0) / (t2 - t0));
      const B2 = lerp(A2, A3, (tt - t1) / (t3 - t1));

      const C = lerp(B1, B2, (tt - t1) / (t2 - t1));

      return C;
    }

    function catmullRomTangent(p0, p1, p2, p3, t) {
      const eps = 0.001;

      const pA = catmullRomCentripetal(p0, p1, p2, p3, Math.max(0, t - eps));
      const pB = catmullRomCentripetal(p0, p1, p2, p3, Math.min(1, t + eps));

      const dx = pB.x - pA.x;
      const dy = pB.y - pA.y;
      const len = Math.hypot(dx, dy) || 1;

      return { x: dx / len, y: dy / len };
    }

    function normalFromTangent(t) {
      return { x: -t.y, y: t.x };
    }

    function renderTrailsGL() {
      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.uniform2f(resLoc, glCanvas.width, glCanvas.height);
      gl.uniform2f(camLoc, camX, camY);
      gl.uniform1f(zoomLoc, zoom);

      const now = Date.now();
      const maxAge = 800;
      const STEPS = 12;

      // HSL to RGB for WebGL (h in degrees, s/l 0-1)
      function hsl2rgb(h, s, l) {
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - c / 2;
        let r, g, b;
        if (h < 60) { r = c; g = x; b = 0; }
        else if (h < 120) { r = x; g = c; b = 0; }
        else if (h < 180) { r = 0; g = c; b = x; }
        else if (h < 240) { r = 0; g = x; b = c; }
        else if (h < 300) { r = x; g = 0; b = c; }
        else { r = c; g = 0; b = x; }
        return [r + m, g + m, b + m];
      }

      for (let i = dragTrails.length - 1; i >= 0; i--) {
        const trail = dragTrails[i];
        const pts = trail.points;
        if (pts.length < 2) continue;

        const hue = getHue(trail.playerId ?? myId);
        const [r, g, b] = hsl2rgb(hue, 0.7, 0.5);

        // Create phantom endpoints for smooth start/end
        const last = pts.length - 1;
        const p0 = { x: 2 * pts[0].x - pts[1].x, y: 2 * pts[0].y - pts[1].y, t: pts[0].t, stam: pts[0].stam };
        const pN = { x: 2 * pts[last].x - pts[last - 1].x, y: 2 * pts[last].y - pts[last - 1].y, t: pts[last].t, stam: pts[last].stam };
        const extended = [p0, ...pts, pN];

        for (let j = 1; j < extended.length - 2; j++) {
          const p0 = extended[j - 1];
          const p1 = extended[j];
          const p2 = extended[j + 1];
          const p3 = extended[j + 2];

          const age = now - p1.t;
          const fade = Math.max(0, 1 - age / maxAge);
          if (fade <= 0) continue;

          const s = p1.stam / 100;
          const alpha = (0.1 + 0.4 * s) * fade;
          const halfWidth = (4 + 16 * s) * fade * 0.5;

          const verts = [];

          for (let k = 0; k <= STEPS; k++) {
            const t = k / STEPS;

            const pos = catmullRomCentripetal(p0, p1, p2, p3, t);
            const tan = catmullRomTangent(p0, p1, p2, p3, t);
            const nrm = normalFromTangent(tan);

            const nx = nrm.x * halfWidth;
            const ny = nrm.y * halfWidth;

            // left
            verts.push(
              pos.x + nx, pos.y + ny,
              pos.x - nx, pos.y - ny
            );
          }

          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.DYNAMIC_DRAW);
          gl.uniform4f(colorLoc, r * alpha, g * alpha, b * alpha, alpha);
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, verts.length / 2);
        }

        if (now - pts[pts.length - 1].t > maxAge) {
          dragTrails.splice(i, 1);
        }
      }
    }

    addEventListener('mousedown', e => { mouseDown = true; mouseX = e.clientX; mouseY = e.clientY; lastClickX = null; });
    addEventListener('mouseup', () => { mouseDown = false; lastClickX = null; currentTrail = null; lastTrailX = null; lastTrailY = null; wasInRange = false; });
    canvas.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
    setInterval(() => {
      if (!mouseDown || !myId) {
        lastClickX = null;
        lastClickY = null;
        currentTrail = null;
        lastTrailX = null;
        lastTrailY = null;
        wasInRange = false;
        return;
      }
      const worldX = camX + (mouseX - canvas.width / 2) / zoom;
      const worldY = camY + (mouseY - canvas.height / 2) / zoom;
      const inRange = isInRange(worldX, worldY);
      const lastInRange = lastClickX !== null && isInRange(lastClickX, lastClickY);

      if (lastClickX !== null && (inRange || lastInRange)) {
        const cur = inRange ? { x: worldX, y: worldY } : clampToRange(worldX, worldY);
        const prev = lastInRange ? { x: lastClickX, y: lastClickY } : clampToRange(lastClickX, lastClickY);
        if (cur && prev) {
          if (!lastInRange && inRange) addToTrail(prev.x, prev.y, stamina);
          addToTrail(cur.x, cur.y, stamina);
          ws.send(JSON.stringify({ type: 'click', x: cur.x, y: cur.y, px: prev.x, py: prev.y }));
        }
      } else {
        currentTrail = null;
        lastTrailX = null;
        lastTrailY = null;
        wasInRange = false;
        if (inRange) {
          addClickEffect(worldX, worldY, stamina);
          ws.send(JSON.stringify({ type: 'click', x: worldX, y: worldY }));
        }
      }
      lastClickX = worldX; lastClickY = worldY;
    }, HOLD_CLICK_INTERVAL);

    function render() {
      const mine = dots.filter(d => d.owner === myId);

      if (mine.length > 0) {
        const cx = mine.reduce((s, d) => s + d.x, 0) / mine.length;
        const cy = mine.reduce((s, d) => s + d.y, 0) / mine.length;
        if (!camInitialized) {
          camX = cx; camY = cy; camInitialized = true;
        } else {
          camX += (cx - camX) * CAM_SMOOTH;
          camY += (cy - camY) * CAM_SMOOTH;
        }

        const minX = Math.min(...mine.map(d => d.x)), maxX = Math.max(...mine.map(d => d.x));
        const minY = Math.min(...mine.map(d => d.y)), maxY = Math.max(...mine.map(d => d.y));
        const bboxW = maxX - minX + 100, bboxH = maxY - minY + 100;
        const targetZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM,
          Math.min(canvas.width * MAX_SCREEN_FILL / bboxW, canvas.height * MAX_SCREEN_FILL / bboxH)));
        zoom += (targetZoom - zoom) * ZOOM_SMOOTH;
      }

      ctx.fillStyle = '#111';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.scale(zoom, zoom);
      ctx.translate(-camX, -camY);

      // Grid
      ctx.strokeStyle = GRID_COLOR;
      ctx.lineWidth = 1 / zoom;
      for (let x = 0; x <= MAP_W; x += GRID_SIZE) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, MAP_H); ctx.stroke();
      }
      for (let y = 0; y <= MAP_H; y += GRID_SIZE) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(MAP_W, y); ctx.stroke();
      }

      // Border
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 2 / zoom;
      ctx.strokeRect(0, 0, MAP_W, MAP_H);

      // Click range areas per player
      const owners = [...new Set(dots.map(d => d.owner).filter(o => o !== null))];
      for (const owner of owners) {
        ctx.fillStyle = getColor(owner, 0.15);
        ctx.beginPath();
        for (const d of dots.filter(d => d.owner === owner)) {
          ctx.moveTo(d.x + CLICK_RANGE, d.y);
          ctx.arc(d.x, d.y, CLICK_RANGE, 0, Math.PI * 2);
        }
        ctx.fill();
      }

      // Connections
      ctx.lineWidth = 1 / zoom;
      for (const [i, j] of connections) {
        const di = dots[i], dj = dots[j];
        if (di.owner !== dj.owner) continue;
        ctx.lineWidth = 1;
        ctx.strokeStyle = (di.owner === dj.owner && di.owner !== null) ? getColor(di.owner) : UNCLAIMED_COLOR;
        ctx.beginPath(); ctx.moveTo(di.x, di.y); ctx.lineTo(dj.x, dj.y); ctx.stroke();
      }

      // Dots
      for (const d of dots) {
        ctx.fillStyle = d.owner !== null ? getColor(d.owner) : UNCLAIMED_COLOR;
        ctx.beginPath(); ctx.arc(d.x, d.y, DOT_RADIUS, 0, Math.PI * 2); ctx.fill();
      }

      // Click effects (rings)
      const now = Date.now();
      for (let i = clickEffects.length - 1; i >= 0; i--) {
        const e = clickEffects[i];
        const progress = (now - e.birth) / CLICK_ANIM_DURATION;
        if (progress > 1) { clickEffects.splice(i, 1); continue; }
        e.radius = e.maxRadius * progress;
        ctx.strokeStyle = `hsla(${e.hue}, 100%, 60%, ${e.alpha * (1 - progress)})`;
        ctx.lineWidth = 6 * (1 - progress);
        ctx.beginPath(); ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2); ctx.stroke();
      }

      ctx.restore();
      renderTrailsGL();

      ctx.fillStyle = '#fff';
      ctx.font = '20px sans-serif';
      ctx.fillText(`Score: ${mine.length}`, 10, 30);
      ctx.fillText(`Stamina: ${Math.round(stamina)}`, 10, 55);

      requestAnimationFrame(render);
    }

    render();
  </script>
</body>

</html>