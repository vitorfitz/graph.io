<!DOCTYPE html>
<html>

<head>
  <title>graph.io</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <canvas id="c"></canvas>
  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    canvas.width = innerWidth;
    canvas.height = innerHeight;

    window.addEventListener('resize', () => {
      canvas.width = innerWidth;
      canvas.height = innerHeight;
    });

    const CAM_SMOOTH = 0.03, ZOOM_SMOOTH = 0.01;
    const GRID_SIZE = 100, GRID_COLOR = '#222';
    const UNCLAIMED_COLOR = "#888";
    const MAX_SCREEN_FILL = 0.6, MIN_ZOOM = 0.5, MAX_ZOOM = 1;
    const HOLD_CLICK_INTERVAL = 1000 / 60;
    const DOT_RADIUS = 6;
    const CLICK_ANIM_DURATION = 727;
    const TRAIL_ANIM_DURATION = 1000;

    let myId = null, MAP_W = 3000, MAP_H = 2000, CLICK_RANGE = 200;
    let dots = [], connections = [], stamina = 100;
    let camX = 0, camY = 0, zoom = 1, camInitialized = false;

    const colors = {};
    function getColor(id, alpha = 1) {
      if (!colors[id]) {
        if (id === myId) {
          colors[id] = '0, 187, 0';
        } else {
          const hue = ((id * 173) % 280) + 160;
          colors[id] = `${hue}, 70%, 50%`;
        }
      }
      return id === myId ? `rgba(${colors[id]}, ${alpha})` : `hsla(${colors[id]}, ${alpha})`;
    }

    const ws = new WebSocket('ws://localhost:8080');

    ws.onmessage = e => {
      const msg = JSON.parse(e.data);
      if (msg.type === 'init') { myId = msg.id; MAP_W = msg.MAP_W; MAP_H = msg.MAP_H; CLICK_RANGE = msg.CLICK_RANGE; }
      else if (msg.type === 'state') { dots = msg.dots; connections = msg.connections; stamina = msg.stamina; }
    };

    let mouseDown = false, mouseX = 0, mouseY = 0, lastClickX = null, lastClickY = null;
    const clickEffects = [];
    const dragTrails = []; // [{points: [{x,y}], birth, width, alpha}]

    function isInRange(x, y) {
      return dots.some(d => d.owner === myId && Math.hypot(d.x - x, d.y - y) < CLICK_RANGE);
    }

    function addClickEffect(x, y, stam) {
      if (!isInRange(x, y)) return;
      const t = stam / 100;
      clickEffects.push({ x, y, radius: 0, maxRadius: 20 + 80 * t, alpha: 0.1 + 0.4 * t, hue: 120, birth: Date.now() });
    }

    let currentTrail = null;
    function addToTrail(x, y, stam) {
      if (!isInRange(x, y)) return;
      if (!currentTrail) {
        currentTrail = { points: [], birth: Date.now() };
        dragTrails.push(currentTrail);
      }
      currentTrail.points.push({ x, y, t: Date.now(), stam });
    }

    canvas.addEventListener('mousedown', e => { mouseDown = true; mouseX = e.clientX; mouseY = e.clientY; lastClickX = null; });
    canvas.addEventListener('mouseup', () => { mouseDown = false; lastClickX = null; currentTrail = null; });
    canvas.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
    setInterval(() => {
      if (!mouseDown || !myId) {
        lastClickX = null;
        lastClickY = null;
        currentTrail = null;
        return;
      }
      const worldX = camX + (mouseX - canvas.width / 2) / zoom;
      const worldY = camY + (mouseY - canvas.height / 2) / zoom;
      if (lastClickX !== null && isInRange(lastClickX, lastClickY)) {
        addToTrail(worldX, worldY, stamina);
        ws.send(JSON.stringify({ type: 'click', x: worldX, y: worldY, px: lastClickX, py: lastClickY }));
      } else if (lastClickX === null) {
        addClickEffect(worldX, worldY, stamina);
        ws.send(JSON.stringify({ type: 'click', x: worldX, y: worldY }));
      }
      lastClickX = worldX; lastClickY = worldY;
    }, HOLD_CLICK_INTERVAL);

    function render() {
      const mine = dots.filter(d => d.owner === myId);

      if (mine.length > 0) {
        const cx = mine.reduce((s, d) => s + d.x, 0) / mine.length;
        const cy = mine.reduce((s, d) => s + d.y, 0) / mine.length;
        if (!camInitialized) {
          camX = cx; camY = cy; camInitialized = true;
        } else {
          camX += (cx - camX) * CAM_SMOOTH;
          camY += (cy - camY) * CAM_SMOOTH;
        }

        const minX = Math.min(...mine.map(d => d.x)), maxX = Math.max(...mine.map(d => d.x));
        const minY = Math.min(...mine.map(d => d.y)), maxY = Math.max(...mine.map(d => d.y));
        const bboxW = maxX - minX + 100, bboxH = maxY - minY + 100;
        const targetZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM,
          Math.min(canvas.width * MAX_SCREEN_FILL / bboxW, canvas.height * MAX_SCREEN_FILL / bboxH)));
        zoom += (targetZoom - zoom) * ZOOM_SMOOTH;
      }

      ctx.fillStyle = '#111';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.scale(zoom, zoom);
      ctx.translate(-camX, -camY);

      // Grid
      ctx.strokeStyle = GRID_COLOR;
      ctx.lineWidth = 1 / zoom;
      for (let x = 0; x <= MAP_W; x += GRID_SIZE) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, MAP_H); ctx.stroke();
      }
      for (let y = 0; y <= MAP_H; y += GRID_SIZE) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(MAP_W, y); ctx.stroke();
      }

      // Border
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 2 / zoom;
      ctx.strokeRect(0, 0, MAP_W, MAP_H);

      // Click range areas per player
      const owners = [...new Set(dots.map(d => d.owner).filter(o => o !== null))];
      for (const owner of owners) {
        ctx.fillStyle = getColor(owner, 0.15);
        ctx.beginPath();
        for (const d of dots.filter(d => d.owner === owner)) {
          ctx.moveTo(d.x + CLICK_RANGE, d.y);
          ctx.arc(d.x, d.y, CLICK_RANGE, 0, Math.PI * 2);
        }
        ctx.fill();
      }

      // Connections
      ctx.lineWidth = 1 / zoom;
      for (const [i, j] of connections) {
        const di = dots[i], dj = dots[j];
        ctx.lineWidth = 1;
        ctx.strokeStyle = (di.owner === dj.owner && di.owner !== null) ? getColor(di.owner) : UNCLAIMED_COLOR;
        ctx.beginPath(); ctx.moveTo(di.x, di.y); ctx.lineTo(dj.x, dj.y); ctx.stroke();
      }

      // Dots
      for (const d of dots) {
        ctx.fillStyle = d.owner !== null ? getColor(d.owner) : UNCLAIMED_COLOR;
        ctx.beginPath(); ctx.arc(d.x, d.y, DOT_RADIUS, 0, Math.PI * 2); ctx.fill();
      }

      // Click effects (rings)
      const now = Date.now();
      for (let i = clickEffects.length - 1; i >= 0; i--) {
        const e = clickEffects[i];
        const progress = (now - e.birth) / CLICK_ANIM_DURATION;
        if (progress > 1) { clickEffects.splice(i, 1); continue; }
        e.radius = e.maxRadius * progress;
        ctx.strokeStyle = `hsla(${e.hue}, 100%, 60%, ${e.alpha * (1 - progress)})`;
        ctx.lineWidth = 6 * (1 - progress);
        ctx.beginPath(); ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2); ctx.stroke();
      }

      // Drag trails (smooth curves)
      for (let i = dragTrails.length - 1; i >= 0; i--) {
        const e = dragTrails[i];
        if (e.points.length < 2) continue;

        const now = Date.now();
        const maxAge = 800;

        ctx.lineCap = 'butt';
        ctx.lineJoin = 'round';

        for (let j = 0; j < e.points.length - 2; j++) {
          const p0 = e.points[j];
          const p1 = e.points[j + 1];
          const p2 = e.points[j + 2];

          const age = now - p0.t;
          const fade = Math.max(0, 1 - age / maxAge);
          if (fade <= 0) continue;

          // Midpoints for smooth quadratic
          const mx1 = (p0.x + p1.x) / 2;
          const my1 = (p0.y + p1.y) / 2;
          const mx2 = (p1.x + p2.x) / 2;
          const my2 = (p1.y + p2.y) / 2;

          const s = p1.stam / 100;
          ctx.strokeStyle = `hsla(120, 100%, 60%, ${(0.1 + 0.4 * s) * fade})`;
          ctx.lineWidth = (4 + 16 * s) * fade;

          ctx.beginPath();
          ctx.moveTo(mx1, my1);
          ctx.quadraticCurveTo(p1.x, p1.y, mx2, my2);
          ctx.stroke();
        }

        // Cleanup when tail fully faded
        if (now - e.points[e.points.length - 1].t > maxAge) {
          dragTrails.splice(i, 1);
        }
      }

      ctx.restore();

      ctx.fillStyle = '#fff';
      ctx.font = '20px sans-serif';
      ctx.fillText(`Score: ${mine.length}`, 10, 30);
      ctx.fillText(`Stamina: ${Math.round(stamina)}`, 10, 55);

      requestAnimationFrame(render);
    }

    render();
  </script>
</body>

</html>